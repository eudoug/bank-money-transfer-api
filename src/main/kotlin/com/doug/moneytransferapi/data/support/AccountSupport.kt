package com.doug.moneytransferapi.data.support

import com.doug.moneytransferapi.data.AccountDataObject
import com.doug.moneytransferapi.data.DataFactory
import com.doug.moneytransferapi.exception.ExceptionHandler
import com.doug.moneytransferapi.model.Account
import com.doug.moneytransferapi.model.CustomerTransaction
import com.doug.moneytransferapi.model.MoneyTransaction
import org.apache.commons.dbutils.DbUtils
import org.apache.log4j.Logger
import java.math.BigDecimal
import java.sql.*
import java.util.ArrayList

class AccountSupport : AccountDataObject {
    /**
     * This method allow a get request that retrieve all accounts on the database.
     */
    override val allAccounts: List<Account>
        @Throws(ExceptionHandler::class)
        get() {
            var connection: Connection? = null
            var statement: PreparedStatement? = null
            var resultSet: ResultSet? = null
            val accounts = ArrayList<Account>()
            try {
                connection = DataFactory.getConnection()
                statement = connection.prepareStatement(SQL_GET_ALL_ACC)
                resultSet = statement.run { executeQuery() }
                while (resultSet.run { next() }) {
                    val account = Account(
                        accountId = resultSet.getLong("AccountId"),
                        customerName = resultSet.getString("CustomerName"),
                        balance = resultSet.getBigDecimal("Balance"),
                        currencyCode = resultSet.getString("CurrencyCode")
                    )
                    if (log.isDebugEnabled)
                        log.debug("getAllAccounts(): Get  Account $account")
                    accounts.add(account)
                }
                return accounts
            } catch (e: SQLException) {
                throw ExceptionHandler("getAccountById(): Error reading account data", e)
            } finally {
                DbUtils.closeQuietly(connection, statement, resultSet)
            }
        }

    /**
     * This method allow a get request that retrieve an account by account id
     */
    @Throws(ExceptionHandler::class)
    override fun getAccountById(accountId: Long): Account {
        var connection: Connection? = null
        var statement: PreparedStatement? = null
        var resultSet: ResultSet? = null
        var acc: Account? = null
        try {
            connection = DataFactory.getConnection()
            statement = connection.prepareStatement(SQL_GET_ACC_BY_ID)
            statement.setLong(1, accountId)
            resultSet = statement.executeQuery()
            if (resultSet.run { next() }) {
                acc = Account(
                    accountId = resultSet.getLong("AccountId"),
                    customerName = resultSet.getString("CustomerName"),
                    balance = resultSet.getBigDecimal("Balance"),
                    currencyCode = resultSet.getString("CurrencyCode")
                )
                if (log.isDebugEnabled)
                    log.debug("Retrieve Account By Id: $acc")
            }
            return acc!!
        } catch (e: SQLException) {
            throw ExceptionHandler("getAccountById(): Error reading account data", e)
        } finally {
            DbUtils.closeQuietly(connection, statement, resultSet)
        }

    }

    /**
     * This method allow to create an account
     */
    @Throws(ExceptionHandler::class)
    override fun insertAccount(account: Account): Long {
        var connection: Connection? = null
        var statement: PreparedStatement? = null
        var autoGeneratedId: ResultSet? = null
        try {
            connection = DataFactory.getConnection()
            statement = connection.prepareStatement(SQL_INSERT_ACCOUNT, Statement.RETURN_GENERATED_KEYS)
            statement.setString(1, account.customerName)
            statement.setBigDecimal(2, account.balance)
            statement.setString(3, account.currencyCode)
            val affectedRows = statement.executeUpdate()
            if (affectedRows == 0) {
                log.error("createAccount(): Creating account failed, no rows affected.")
                throw ExceptionHandler("Account Cannot be created")
            }
            autoGeneratedId = statement.generatedKeys
            if (autoGeneratedId.run { next() }) {
                return autoGeneratedId.getLong(1)
            } else {
                log.error("Creating account failed, no ID obtained.")
                throw ExceptionHandler("Account Cannot be created")
            }
        } catch (e: SQLException) {
            log.error("Error Inserting Account  $account")
            throw ExceptionHandler("createAccount(): Error creating customer account $account", e)
        } finally {
            DbUtils.closeQuietly(connection, statement, autoGeneratedId)
        }
    }

    /**
     * This method allow to delete account by id
     */
    @Throws(ExceptionHandler::class)
    override fun deleteAccountById(accountId: Long): Int {
        var connection: Connection? = null
        var statement: PreparedStatement? = null
        try {
            connection = DataFactory.getConnection()
            statement = connection.prepareStatement(SQL_DELETE_ACC_BY_ID)
            statement.setLong(1, accountId)
            return statement.executeUpdate()
        } catch (e: SQLException) {
            throw ExceptionHandler("deleteAccountById(): Error deleting customer account Id $accountId", e)
        } finally {
            DbUtils.closeQuietly(connection)
            DbUtils.closeQuietly(statement)
        }
    }

    /**
     * This method allow to update account balance
     */
    @Throws(ExceptionHandler::class)
    override fun updateAccountBalance(accountId: Long, deltaAmount: BigDecimal): Int {
        var connection: Connection? = null
        var lockStatement: PreparedStatement? = null
        var updateStatement: PreparedStatement? = null
        var resultSet: ResultSet? = null
        var targetAccount: Account? = null
        var updateCount = -1
        try {
            connection = DataFactory.getConnection()
            connection.autoCommit = false
            // lock account for writing:
            lockStatement = connection.prepareStatement(SQL_LOCK_ACC_BY_ID)
            lockStatement.setLong(1, accountId)
            resultSet = lockStatement.executeQuery()
            if (resultSet.run { next() }) {
                targetAccount = Account(
                    accountId = resultSet.getLong("AccountId"),
                    customerName = resultSet.getString("CustomerName"),
                    balance = resultSet.getBigDecimal("Balance"),
                    currencyCode = resultSet.getString("CurrencyCode")
                )
                if (log.isDebugEnabled)
                    log.debug("updateAccountBalance from Account: $targetAccount")
            }

            // update account upon success locking
            val balance = targetAccount?.balance?.add(deltaAmount)
            if (balance!! < MoneyTransaction.zeroAmount) {
                throw ExceptionHandler("Not sufficient Fund for account: $accountId")
            }

            updateStatement = connection.prepareStatement(SQL_UPDATE_ACC_BALANCE)
            updateStatement.setBigDecimal(1, balance)
            updateStatement.setLong(2, accountId)
            updateCount = updateStatement.executeUpdate()
            connection.commit()
            if (log.isDebugEnabled)
                log.debug("New Balance after Update: $targetAccount")
            return updateCount
        } catch (se: SQLException) {
            // rollback transaction if exception occurs
            log.error("updateAccountBalance(): Customer Transaction Failed, rollback initiated for: $accountId", se)
            try {
                connection?.rollback()
            } catch (re: SQLException) {
                throw ExceptionHandler("Fail to rollback transaction", re)
            }

        } finally {
            DbUtils.closeQuietly(connection)
            DbUtils.closeQuietly(resultSet)
            DbUtils.closeQuietly(lockStatement)
            DbUtils.closeQuietly(updateStatement)
        }
        return updateCount
    }

    /**
     * This method allow transfer balance between customers accounts
     */
    @Throws(ExceptionHandler::class)
    override fun transferAccountBalance(customerTransaction: CustomerTransaction): Int {
        var result = -1
        var connection: Connection? = null
        var lockStatement: PreparedStatement? = null
        var updateStatement: PreparedStatement? = null
        var resultSet: ResultSet? = null
        var fromAccount: Account? = null
        var toAccount: Account? = null

        try {
            connection = DataFactory.getConnection()
            connection.autoCommit = false
            // lock the credit and debit account for writing:
            lockStatement = connection.prepareStatement(SQL_LOCK_ACC_BY_ID)
            lockStatement.setLong(1, customerTransaction.fromAccountId!!)
            resultSet = lockStatement.executeQuery()
            if (resultSet.run { next() }) {
                fromAccount = Account(
                    accountId = resultSet.getLong("AccountId"),
                    customerName = resultSet.getString("CustomerName"),
                    balance = resultSet.getBigDecimal("Balance"),
                    currencyCode = resultSet.getString("CurrencyCode")
                )
                if (log.isDebugEnabled)
                    log.debug("""Transfer Balance from Account: $fromAccount""")
            }
            lockStatement = connection.prepareStatement(SQL_LOCK_ACC_BY_ID)
            lockStatement.setLong(1, customerTransaction.toAccountId!!)
            resultSet = lockStatement.executeQuery()
            if (resultSet.next()) {
                toAccount = Account(
                    accountId = resultSet.getLong("AccountId"),
                    customerName = resultSet.getString("CustomerName"),
                    balance = resultSet.getBigDecimal("Balance"),
                    currencyCode = resultSet.getString("CurrencyCode")
                )
                if (log.isDebugEnabled)
                    log.debug("""Transfer Balance to Account: $toAccount""")
            }

            // check transaction currency
            if (fromAccount?.currencyCode != customerTransaction.currencyCode) {
                throw ExceptionHandler(
                    "Fail to transfer Fund, currency are different"
                )
            }

            // check if currency is the same for both accounts
            if (fromAccount?.currencyCode != toAccount?.currencyCode) {
                throw ExceptionHandler(
                    "Fail to transfer Fund, different currency"
                )
            }

            // check if there are enough funds in the source account
            val fromAccountLeftOver = fromAccount?.balance?.subtract(customerTransaction.amount)
            if (fromAccountLeftOver?.compareTo(MoneyTransaction.zeroAmount)!! < 0) {
                throw ExceptionHandler("Not enough funds to transfer")
            }

            // proceed with update
            updateStatement = connection.prepareStatement(SQL_UPDATE_ACC_BALANCE)
            updateStatement.setBigDecimal(1, fromAccountLeftOver)
            updateStatement.setLong(2, customerTransaction.fromAccountId!!)
            updateStatement.addBatch()
            updateStatement.setBigDecimal(1, toAccount?.balance?.add(customerTransaction.amount))
            updateStatement.setLong(2, customerTransaction.toAccountId!!)
            updateStatement.addBatch()
            val rowsUpdated = updateStatement.executeBatch()
            result = rowsUpdated[0] + rowsUpdated[1]
            if (log.isDebugEnabled) {
                log.debug("Number of rows updated for the transfer : $result")
            }
            // If there is no error, commit the transaction
            connection.commit()
        } catch (se: SQLException) {
            // this will allow a rollback transaction if exception occurs
            log.error(
                "transferAccountBalance(): Customer Transaction Failed, rollback initiated for: $customerTransaction",
                se
            )
            try {
                connection?.rollback()
            } catch (re: SQLException) {
                throw ExceptionHandler("Fail to rollback transaction", re)
            }

        } finally {
            DbUtils.closeQuietly(connection)
            DbUtils.closeQuietly(resultSet)
            DbUtils.closeQuietly(lockStatement)
            DbUtils.closeQuietly(updateStatement)
        }
        return result
    }

    companion object {

        private val log = Logger.getLogger(AccountSupport::class.java)
        private const val SQL_GET_ACC_BY_ID = "SELECT * FROM Account WHERE AccountId = ? "
        private const val SQL_LOCK_ACC_BY_ID = "SELECT * FROM Account WHERE AccountId = ? FOR UPDATE"
        private const val SQL_INSERT_ACCOUNT = "INSERT INTO Account (CustomerName, Balance, CurrencyCode) VALUES (?, ?, ?)"
        private const val SQL_UPDATE_ACC_BALANCE = "UPDATE Account SET Balance = ? WHERE AccountId = ? "
        private const val SQL_GET_ALL_ACC = "SELECT * FROM Account"
        private const val SQL_DELETE_ACC_BY_ID = "DELETE FROM Account WHERE AccountId = ?"
    }

}