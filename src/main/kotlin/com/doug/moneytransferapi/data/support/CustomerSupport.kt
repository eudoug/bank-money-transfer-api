package com.doug.moneytransferapi.data.support

import com.doug.moneytransferapi.data.DataFactory
import com.doug.moneytransferapi.data.CustomerDataObject
import com.doug.moneytransferapi.exception.ExceptionHandler
import com.doug.moneytransferapi.model.Customer
import org.apache.commons.dbutils.DbUtils
import org.apache.log4j.Logger
import java.sql.*
import java.util.ArrayList

class CustomerSupport : CustomerDataObject {

    /**
     * This method allow a get request that retrieve all customers on the database.
     */
    override val allCustomer: List<Customer>
        @Throws(ExceptionHandler::class)
        get() {
            var connection: Connection? = null
            var statement: PreparedStatement? = null
            var resultSet: ResultSet? = null
            val customers = ArrayList<Customer>()
            try {
                connection = DataFactory.getConnection()
                statement = connection.prepareStatement(SQL_GET_ALL_CUSTOMERS)
                resultSet = statement.run { executeQuery() }
                while (resultSet.next()) {
                    val customer = Customer(
                        customerId = resultSet.getLong("CustomerId"),
                        customerName = resultSet.getString("CustomerName"),
                        emailAddress = resultSet.getString("EmailAddress")
                    )
                    if (log.isDebugEnabled)
                        log.debug("getAllCustomers() Retrieve Customer: $customer")
                    customers.add(customer)
                }
                return customers
            } catch (e: SQLException) {
                throw ExceptionHandler(ERROR_READING_DATA, e)
            } finally {
                DbUtils.closeQuietly(connection, statement, resultSet)
            }
        }

    /**
     * This method allow a get request that retrieve an customer by customer id
     */
    @Throws(ExceptionHandler::class)
    override fun getCustomerById(customerId: Long): Customer {
        var connection: Connection? = null
        var statement: PreparedStatement? = null
        var resultSet: ResultSet? = null
        var customer: Customer? = null
        try {
            connection = DataFactory.getConnection()
            statement = connection.prepareStatement(SQL_GET_CUSTOMER_BY_ID)
            statement.setLong(1, customerId)
            resultSet = statement.executeQuery()
            if (resultSet!!.next()) {
                customer = Customer(
                    customerId = resultSet.getLong("customerId"),
                    customerName = resultSet.getString("customerName"),
                    emailAddress = resultSet.getString("emailAddress")
                )
                if (log.isDebugEnabled)
                    log.debug("getCustomerById(): Retrieve Customer: $customer")
            }
            return customer!!
        } catch (e: SQLException) {
            throw ExceptionHandler(ERROR_READING_DATA, e)
        } finally {
            DbUtils.closeQuietly(connection, statement, resultSet)
        }
    }

    /**
     * This method allow a get request that retrieve an customer by customerName
     */
    @Throws(ExceptionHandler::class)
    override fun getCustomerByName(customerName: String): Customer? {
        var connection: Connection? = null
        var statement: PreparedStatement? = null
        var resultSet: ResultSet? = null
        var customer: Customer? = null
        try {
            connection = DataFactory.getConnection()
            statement = connection.prepareStatement(SQL_GET_CUSTOMER_BY_NAME)
            statement.setString(1, customerName)
            resultSet = statement.executeQuery()
            if (resultSet.next()) {
                customer = Customer(
                    customerId = resultSet.getLong("CustomerId"),
                    customerName = resultSet.getString("CustomerName"),
                    emailAddress = resultSet.getString("EmailAddress")
                )
                if (log.isDebugEnabled) {
                    log.debug("Retrieve Customer: $customer")
                }
            }
            return customer
        } catch (e: SQLException) {
            throw ExceptionHandler(ERROR_READING_DATA, e)
        } finally {
            DbUtils.closeQuietly(connection, statement, resultSet)
        }
    }

    /**
     * This method allow insert a new customer
     */
    @Throws(ExceptionHandler::class)
    override fun insertCustomer(customer: Customer): Long {
        var connection: Connection? = null
        var statement: PreparedStatement? = null
        var autoGeneratedId: ResultSet? = null
        try {
            connection = DataFactory.getConnection()
            statement = connection.prepareStatement(SQL_INSERT_CUSTOMER, Statement.RETURN_GENERATED_KEYS)
            statement.setString(1, customer.customerName)
            statement.setString(2, customer.emailAddress)
            val affectedRows = statement.executeUpdate()
            if (affectedRows == 0) {
                log.error("insertCustomer(): Creating customer failed, no rows affected.$customer")
                throw ExceptionHandler("Customers Cannot be created")
            }
            autoGeneratedId = statement.generatedKeys
            if (autoGeneratedId.run { next() }) {
                return autoGeneratedId.getLong(1)
            } else {
                log.error("insertCustomer():  Creating customer failed, no ID obtained.$customer")
                throw ExceptionHandler("Customers Cannot be created")
            }
        } catch (e: SQLException) {
            log.error("Error Inserting Customer :$customer")
            throw ExceptionHandler(ERROR_READING_DATA, e)
        } finally {
            DbUtils.closeQuietly(connection, statement, autoGeneratedId)
        }

    }

    /**
     * This method allow to update a existing Customer
     */
    @Throws(ExceptionHandler::class)
    override fun updateCustomer(customerId: Long?, customer: Customer): Int {
        var connection: Connection? = null
        var statement: PreparedStatement? = null

        try {
            connection = DataFactory.getConnection()
            statement = connection.prepareStatement(SQL_UPDATE_CUSTOMER)
            statement.setString(1, customer.customerName)
            statement.setString(2, customer.emailAddress)
            statement.setLong(3, customerId!!)
            return statement.executeUpdate()
        } catch (e: SQLException) {
            log.error("Error Updating Customer :$customer")
            throw ExceptionHandler(ERROR_READING_DATA, e)
        } finally {
            DbUtils.closeQuietly(connection)
            DbUtils.closeQuietly(statement)
        }
    }

    /**
     * This method allow delete a Customer
     */
    @Throws(ExceptionHandler::class)
    override fun deleteCustomer(customerId: Long): Int {
        var connection: Connection? = null
        var statement: PreparedStatement? = null

        try {
            connection = DataFactory.getConnection()
            statement = connection.prepareStatement(SQL_DELETE_CUSTOMER_BY_ID)
            statement.setLong(1, customerId)
            return statement.executeUpdate()
        } catch (e: SQLException) {
            log.error("Error Deleting Customer :$customerId")
            throw ExceptionHandler("Error Deleting Customer Id:$customerId", e)
        } finally {
            DbUtils.closeQuietly(connection)
            DbUtils.closeQuietly(statement)
        }
    }

    companion object {

        private val log = Logger.getLogger(CustomerSupport::class.java)
        private const val SQL_GET_CUSTOMER_BY_ID = "SELECT * FROM Customer WHERE CustomerId = ? "
        private const val SQL_GET_ALL_CUSTOMERS = "SELECT * FROM Customer"
        private const val SQL_GET_CUSTOMER_BY_NAME = "SELECT * FROM Customer WHERE CustomerName = ? "
        private const val SQL_INSERT_CUSTOMER = "INSERT INTO Customer (CustomerName, EmailAddress) VALUES (?, ?)"
        private const val SQL_UPDATE_CUSTOMER = "UPDATE Customer SET CustomerName = ?, EmailAddress = ? WHERE CustomerId = ? "
        private const val SQL_DELETE_CUSTOMER_BY_ID = "DELETE FROM Customer WHERE CustomerId = ? "
        private const val ERROR_READING_DATA = "Error reading customer data"

    }

}