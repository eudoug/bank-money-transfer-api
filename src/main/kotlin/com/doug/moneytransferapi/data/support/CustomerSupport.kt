package com.doug.moneytransferapi.data.support

import com.doug.moneytransferapi.data.DataFactory
import com.doug.moneytransferapi.data.CustomerDataObject
import com.doug.moneytransferapi.exception.ExceptionHandler
import com.doug.moneytransferapi.model.Customer
import org.apache.commons.dbutils.DbUtils
import org.apache.log4j.Logger
import java.sql.*
import java.util.ArrayList

class CustomerSupport : CustomerDataObject {

    /**
     * Find all customer
     */
    override val allCustomer: List<Customer>
        @Throws(ExceptionHandler::class)
        get() {
            var connection: Connection? = null
            var stmt: PreparedStatement? = null
            var rs: ResultSet? = null
            val customers = ArrayList<Customer>()
            try {
                connection = DataFactory.getConnection()
                stmt = connection.prepareStatement(SQL_GET_ALL_CUSTOMERS)
                rs = stmt.run { executeQuery() }
                while (rs.next()) {
                    val customer = Customer(
                        rs.getLong("CustomerId"),
                        rs.getString("CustomerName"),
                        rs.getString("EmailAddress")
                    )
                    if (log.isDebugEnabled)
                        log.debug("getAllCustomers() Retrieve Customer: $customer")
                }
                return customers
            } catch (e: SQLException) {
                throw ExceptionHandler(ERROR_READING_DATA, e)
            } finally {
                DbUtils.closeQuietly(connection, stmt, rs)
            }
        }

    /**
     * Find customer by customerId
     */
    @Throws(ExceptionHandler::class)
    override fun getCustomerById(customerId: Long): Customer {
        var connection: Connection? = null
        var stmt: PreparedStatement? = null
        var rs: ResultSet? = null
        var customer: Customer? = null
        try {
            connection = DataFactory.getConnection()
            stmt = connection.prepareStatement(SQL_GET_CUSTOMER_BY_ID)
            stmt.setLong(1, customerId)
            rs = stmt.executeQuery()
            if (rs!!.next()) {
                customer = Customer(
                    rs.getLong("customerId"),
                    rs.getString("customerName"),
                    rs.getString("emailAddress")
                )
                if (log.isDebugEnabled)
                    log.debug("getCustomerById(): Retrieve Customer: $customer")
            }
            return customer!!
        } catch (e: SQLException) {
            throw ExceptionHandler(ERROR_READING_DATA, e)
        } finally {
            DbUtils.closeQuietly(connection, stmt, rs)
        }
    }

    /**
     * Find customer by customerName
     */
    @Throws(ExceptionHandler::class)
    override fun getCustomerByName(customerName: String): Customer? {
        var connection: Connection? = null
        var stmt: PreparedStatement? = null
        var rs: ResultSet? = null
        var customer: Customer? = null
        try {
            connection = DataFactory.getConnection()
            stmt = connection.prepareStatement(SQL_GET_CUSTOMER_BY_NAME)
            stmt.setString(1, customerName)
            rs = stmt.executeQuery()
            if (rs.next()) {
                customer = Customer(
                    customerId = rs.getLong("CustomerId"),
                    customerName = rs.getString("CustomerName"),
                    emailAddress = rs.getString("EmailAddress")
                )
                if (log.isDebugEnabled) {
                    log.debug("Retrieve Customer: $customer")
                }
            }
            return customer
        } catch (e: SQLException) {
            throw ExceptionHandler(ERROR_READING_DATA, e)
        } finally {
            DbUtils.closeQuietly(connection, stmt, rs)
        }
    }

    /**
     * Save Customer
     */
    @Throws(ExceptionHandler::class)
    override fun insertCustomer(customer: Customer): Long {
        var connection: Connection? = null
        var stmt: PreparedStatement? = null
        var autoGeneratedId: ResultSet? = null
        try {
            connection = DataFactory.getConnection()
            stmt = connection.prepareStatement(SQL_INSERT_CUSTOMER, Statement.RETURN_GENERATED_KEYS)
            stmt.setString(1, customer.customerName)
            stmt.setString(2, customer.emailAddress)
            val affectedRows = stmt.executeUpdate()
            if (affectedRows == 0) {
                log.error("insertCustomer(): Creating customer failed, no rows affected.$customer")
                throw ExceptionHandler("Customers Cannot be created")
            }
            autoGeneratedId = stmt.generatedKeys
            if (autoGeneratedId.run { next() }) {
                return autoGeneratedId.getLong(1)
            } else {
                log.error("insertCustomer():  Creating customer failed, no ID obtained.$customer")
                throw ExceptionHandler("Customers Cannot be created")
            }
        } catch (e: SQLException) {
            log.error("Error Inserting Customer :$customer")
            throw ExceptionHandler(ERROR_READING_DATA, e)
        } finally {
            DbUtils.closeQuietly(connection, stmt, autoGeneratedId)
        }

    }

    /**
     * Update Customer
     */
    @Throws(ExceptionHandler::class)
    override fun updateCustomer(customerId: Long?, customer: Customer): Int {
        var connection: Connection? = null
        var stmt: PreparedStatement? = null

        try {
            connection = DataFactory.getConnection()
            stmt = connection.prepareStatement(SQL_UPDATE_CUSTOMER)
            stmt.setString(1, customer.customerName)
            stmt.setString(2, customer.emailAddress)
            stmt.setLong(3, customerId!!)
            return stmt.executeUpdate()
        } catch (e: SQLException) {
            log.error("Error Updating Customer :$customer")
            throw ExceptionHandler(ERROR_READING_DATA, e)
        } finally {
            DbUtils.closeQuietly(connection)
            DbUtils.closeQuietly(stmt)
        }
    }

    /**
     * Delete Customer
     */
    @Throws(ExceptionHandler::class)
    override fun deleteCustomer(customerId: Long): Int {
        var connection: Connection? = null
        var stmt: PreparedStatement? = null

        try {
            connection = DataFactory.getConnection()
            stmt = connection.prepareStatement(SQL_DELETE_CUSTOMER_BY_ID)
            stmt.setLong(1, customerId)
            return stmt.executeUpdate()
        } catch (e: SQLException) {
            log.error("Error Deleting Customer :$customerId")
            throw ExceptionHandler("Error Deleting Customer Id:$customerId", e)
        } finally {
            DbUtils.closeQuietly(connection)
            DbUtils.closeQuietly(stmt)
        }
    }

    companion object {

        private val log = Logger.getLogger(CustomerSupport::class.java)
        private const val SQL_GET_CUSTOMER_BY_ID = "SELECT * FROM Customer WHERE CustomerId = ? "
        private const val SQL_GET_ALL_CUSTOMERS = "SELECT * FROM Customer"
        private const val SQL_GET_CUSTOMER_BY_NAME = "SELECT * FROM Customer WHERE CustomerName = ? "
        private const val SQL_INSERT_CUSTOMER = "INSERT INTO Customer (CustomerName, EmailAddress) VALUES (?, ?)"
        private const val SQL_UPDATE_CUSTOMER = "UPDATE Customer SET CustomerName = ?, EmailAddress = ? WHERE CustomerId = ? "
        private const val SQL_DELETE_CUSTOMER_BY_ID = "DELETE FROM Customer WHERE CustomerId = ? "
        private const val ERROR_READING_DATA = "Error reading customer data"

    }

}